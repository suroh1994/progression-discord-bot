// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package postgres

import (
	"context"
)

const endLeague = `-- name: EndLeague :exec
UPDATE league
SET active= false
WHERE active = true
`

func (q *Queries) EndLeague(ctx context.Context) error {
	_, err := q.db.Exec(ctx, endLeague)
	return err
}

const getAllPlayers = `-- name: GetAllPlayers :many
SELECT id, wild_card_count, wild_pack_count
FROM player
`

func (q *Queries) GetAllPlayers(ctx context.Context) ([]Player, error) {
	rows, err := q.db.Query(ctx, getAllPlayers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Player
	for rows.Next() {
		var i Player
		if err := rows.Scan(&i.ID, &i.WildCardCount, &i.WildPackCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCards = `-- name: GetCards :many
SELECT name, set_code, collector_number, count
FROM player_card_pool
WHERE player_id = $1
`

type GetCardsRow struct {
	Name            string
	SetCode         string
	CollectorNumber int32
	Count           int32
}

func (q *Queries) GetCards(ctx context.Context, playerID string) ([]GetCardsRow, error) {
	rows, err := q.db.Query(ctx, getCards, playerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCardsRow
	for rows.Next() {
		var i GetCardsRow
		if err := rows.Scan(
			&i.Name,
			&i.SetCode,
			&i.CollectorNumber,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentRound = `-- name: GetCurrentRound :one
SELECT round
FROM league
where active = true
`

func (q *Queries) GetCurrentRound(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, getCurrentRound)
	var round int32
	err := row.Scan(&round)
	return round, err
}

const getPairing = `-- name: GetPairing :one
SELECT round, player_id1, player_id2, wins1, wins2, draws
from pairing
WHERE round = $1
  AND (player_id1 = $2 or player_id2 = $2)
`

type GetPairingParams struct {
	Round     int32
	PlayerId1 string
}

func (q *Queries) GetPairing(ctx context.Context, arg GetPairingParams) (Pairing, error) {
	row := q.db.QueryRow(ctx, getPairing, arg.Round, arg.PlayerId1)
	var i Pairing
	err := row.Scan(
		&i.Round,
		&i.PlayerId1,
		&i.PlayerId2,
		&i.Wins1,
		&i.Wins2,
		&i.Draws,
	)
	return i, err
}

const getPlayer = `-- name: GetPlayer :one
SELECT id, wild_card_count, wild_pack_count
FROM player
WHERE id = $1
`

func (q *Queries) GetPlayer(ctx context.Context, id string) (Player, error) {
	row := q.db.QueryRow(ctx, getPlayer, id)
	var i Player
	err := row.Scan(&i.ID, &i.WildCardCount, &i.WildPackCount)
	return i, err
}

const startLeague = `-- name: StartLeague :exec
INSERT INTO league (round, active, created_at)
VALUES (0, true, now())
`

func (q *Queries) StartLeague(ctx context.Context) error {
	_, err := q.db.Exec(ctx, startLeague)
	return err
}

const storeCards = `-- name: StoreCards :exec
INSERT INTO player_card_pool (player_id, name, set_code, collector_number, count)
SELECT unnest($1::text[]), -- id
       unnest($2::text[]), -- name
       unnest($3::text[]), -- set_code
       unnest($4::int[]),  -- collector_number
       unnest($5::int[])   -- count
ON CONFLICT (player_id, set_code, collector_number)
    DO UPDATE SET count = EXCLUDED.count + player_card_pool.count
`

type StoreCardsParams struct {
	PlayerID        []string
	Name            []string
	SetCode         []string
	CollectorNumber []int32
	Count           []int32
}

func (q *Queries) StoreCards(ctx context.Context, arg StoreCardsParams) error {
	_, err := q.db.Exec(ctx, storeCards,
		arg.PlayerID,
		arg.Name,
		arg.SetCode,
		arg.CollectorNumber,
		arg.Count,
	)
	return err
}

const storePairings = `-- name: StorePairings :exec
INSERT INTO pairing (round, player_id1, player_id2, wins1, wins2, draws)
SELECT unnest($1::int[]),  -- round
       unnest($2::text[]), -- player_id1
       unnest($3::text[]), -- player_id2
       unnest($4::int[]),  -- wins1
       unnest($5::int[]),  -- wins2
       unnest($6::int[])
`

type StorePairingsParams struct {
	Round     []int32
	PlayerId1 []string
	PlayerId2 []string
	Wins1     []int32
	Wins2     []int32
	Draws     []int32
}

func (q *Queries) StorePairings(ctx context.Context, arg StorePairingsParams) error {
	_, err := q.db.Exec(ctx, storePairings,
		arg.Round,
		arg.PlayerId1,
		arg.PlayerId2,
		arg.Wins1,
		arg.Wins2,
		arg.Draws,
	)
	return err
}

const updatePairing = `-- name: UpdatePairing :exec

UPDATE pairing
SET wins1 = $4,
    wins2 = $5,
    draws = $6
WHERE round = $1
  AND player_id1 = $2
  AND player_id2 = $3
  AND wins1 = 0
  AND wins2 = 0
  AND draws = 0
`

type UpdatePairingParams struct {
	Round     int32
	PlayerId1 string
	PlayerId2 string
	Wins1     int32
	Wins2     int32
	Draws     int32
}

// draws
// draws
func (q *Queries) UpdatePairing(ctx context.Context, arg UpdatePairingParams) error {
	_, err := q.db.Exec(ctx, updatePairing,
		arg.Round,
		arg.PlayerId1,
		arg.PlayerId2,
		arg.Wins1,
		arg.Wins2,
		arg.Draws,
	)
	return err
}

const updatePlayer = `-- name: UpdatePlayer :exec
UPDATE player
SET wild_card_count = $2,
    wild_pack_count = $3
WHERE ID = $1
`

type UpdatePlayerParams struct {
	ID            string
	WildCardCount int32
	WildPackCount int32
}

func (q *Queries) UpdatePlayer(ctx context.Context, arg UpdatePlayerParams) error {
	_, err := q.db.Exec(ctx, updatePlayer, arg.ID, arg.WildCardCount, arg.WildPackCount)
	return err
}
